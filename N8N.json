{
	"name": "Sistema Multi-Agente: Informes Médicos con IA",
	"nodes": [
		{
			"parameters": {
				"httpMethod": "POST",
				"path": "generate-report-from-audio",
				"responseMode": "responseNode",
				"options": {}
			},
			"id": "webhook-trigger",
			"name": "Webhook Trigger",
			"type": "n8n-nodes-base.webhook",
			"typeVersion": 2,
			"position": [250, 400]
		},
		{
			"parameters": {
				"jsCode": "const webhookData = $json.body || $json;\n\nif (!webhookData.audioUrl) {\n  throw new Error('audioUrl requerido');\n}\n\nif (!webhookData.groqApiKey) {\n  throw new Error('groqApiKey requerido');\n}\n\n// Validar que nextAppUrl esté configurado y no sea localhost\nif (!webhookData.nextAppUrl || webhookData.nextAppUrl.includes('localhost')) {\n  throw new Error('nextAppUrl no está configurado correctamente. Debe ser la URL pública de la aplicación en producción (ej: https://tu-dominio.com). Verifica la variable de entorno NEXT_PUBLIC_APP_URL.');\n}\n\nreturn {\n  audioUrl: webhookData.audioUrl,\n  groqApiKey: webhookData.groqApiKey,\n  consultationId: webhookData.consultationId,\n  doctorId: webhookData.doctorId,\n  reportType: webhookData.reportType || 'gynecology',\n  specialty: webhookData.specialty || '',\n  patientData: webhookData.patientData || {},\n  consultationData: webhookData.consultationData || {},\n  medicProfile: webhookData.medicProfile || {},\n  nextAppUrl: webhookData.nextAppUrl,\n  n8nApiKey: webhookData.n8nApiKey,\n  timestamp: new Date().toISOString()\n};"
			},
			"id": "normalize-input",
			"name": "1. Normalizar Entrada",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [450, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "={{ $json.nextAppUrl }}/api/groq/transcribe",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={\n  \"audioUrl\": \"{{ $json.audioUrl }}\",\n  \"groqApiKey\": \"{{ $json.groqApiKey }}\"\n}",
				"options": {}
			},
			"id": "transcribe-audio",
			"name": "2. Transcribir Audio (Groq Whisper)",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [650, 400]
		},
		{
			"parameters": {
				"jsCode": "const transcriptionResponse = $json;\nconst rawText = transcriptionResponse.text || transcriptionResponse.transcription?.text || '';\nconst inputData = $('1. Normalizar Entrada').item.json;\n\nif (!rawText) {\n  throw new Error('No se pudo obtener transcripción del audio');\n}\n\nconst systemPrompt = `Eres un agente especializado en LIMPIEZA Y ESTRUCTURACIÓN de transcripciones médicas.\n\nTu ÚNICA tarea es:\n1. Eliminar muletillas y ruido verbal (eh, mm, este, bueno, entonces, o sea)\n2. Corregir errores de transcripción obvios\n3. Mantener TODO el contenido médico intacto\n4. Identificar secciones clínicas implícitas\n5. Normalizar puntuación\n\nNO interpretes, NO resumas, NO modifiques el contenido clínico.\n\nResponde SOLO con JSON:\n{\n  \"cleaned_text\": \"texto limpio completo\",\n  \"detected_sections\": [\"motivo\", \"examen\", \"diagnóstico\", etc],\n  \"quality_score\": 0-100,\n  \"warnings\": [\"advertencias si las hay\"]\n}`;\n\nconst userPrompt = `TRANSCRIPCIÓN ORIGINAL:\n${rawText}\n\nESPECIALIDAD: ${inputData.specialty}\nTIPO DE INFORME: ${inputData.reportType}\n\nLIMPIA esta transcripción manteniendo TODO el contenido médico.`;\n\nconst payload = {\n  model: 'llama-3.3-70b-versatile',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  temperature: 0.1,\n  response_format: { type: 'json_object' }\n};\n\nreturn {\n  ...inputData,\n  rawTranscription: rawText,\n  agentPayload: payload\n};"
			},
			"id": "agent1-prepare",
			"name": "AGENTE 1: Preparar Limpieza",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [850, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "https://api.groq.com/openai/v1/chat/completions",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Authorization",
							"value": "=Bearer {{ $json.groqApiKey }}"
						},
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={{ $json.agentPayload }}",
				"options": {}
			},
			"id": "agent1-execute",
			"name": "AGENTE 1: Ejecutar",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [1050, 400]
		},
		{
			"parameters": {
				"jsCode": "const agent1Response = $json.choices?.[0]?.message?.content;\nlet cleanedData;\n\ntry {\n  cleanedData = JSON.parse(agent1Response);\n} catch (e) {\n  throw new Error('AGENTE 1 falló: ' + e.message);\n}\n\nconst inputData = $('AGENTE 1: Preparar Limpieza').item.json;\nconst cleanedText = cleanedData.cleaned_text || '';\nconst detectedSections = cleanedData.detected_sections || [];\n\nconst systemPrompt = `Eres un agente EXTRACTOR CLÍNICO especializado en medicina ${inputData.specialty}.\n\nTu misión:\n1. Identificar y extraer TODOS los datos clínicos mencionados\n2. Mapear conceptos similares al mismo campo (\"dolor de vientre\" = \"dolor abdominal\" = motivo)\n3. Interpretar valores implícitos (\"mamas grandes\" → tamaño: \"grandes\")\n4. Detectar negaciones (\"sin alergias\", \"niega cirugías\")\n5. Extraer fechas, medidas, y datos cuantitativos\n\nCRÍTICO:\n- Si el doctor dice \"no voy a llenar X\" → ese campo NO debe aparecer\n- Si no se menciona algo → null\n- NO inventes datos\n- Respeta la intención del médico\n\nResponde con JSON estructurado según la especialidad.`;\n\nlet fieldSchema = {};\nif (inputData.reportType === 'gynecology') {\n  fieldSchema = {\n    motivo_consulta: \"string | null\",\n    antecedentes: {\n      alergias: \"string | null\",\n      quirurgicos: \"string | null\",\n      madre: \"string | null\",\n      padre: \"string | null\",\n      cancer_mama: \"boolean | null\"\n    },\n    ginecologicos: {\n      ultima_regla: \"date | null\",\n      historia_obstetrica: \"string | null\",\n      metodo_anticonceptivo: \"string | null\",\n      its: \"string | null\",\n      menstruacion_tipo: \"string | null\",\n      dismenorrea: \"boolean | null\",\n      primera_relacion: \"string | null\",\n      parejas_sexuales: \"number | null\"\n    },\n    examen_fisico: {\n      condiciones_generales: \"string | null\",\n      mamas: {\n        tamaño: \"string | null\",\n        simetria: \"string | null\",\n        cap: \"string | null\",\n        secrecion: \"string | null\"\n      },\n      abdomen: \"string | null\",\n      fosas_axilares: \"string | null\",\n      genitales_externos: \"string | null\",\n      especuloscopia: \"string | null\",\n      tacto: {\n        cervix: \"string | null\",\n        fondo_sacos: \"string | null\",\n        anexos: \"string | null\"\n      }\n    },\n    ecografia: {\n      utero_dimensiones: \"string | null\",\n      interfase_endometrial: \"string | null\",\n      ovario_izquierdo: \"string | null\",\n      ovario_derecho: \"string | null\",\n      liquido_fondo_saco: \"string | null\"\n    },\n    campos_no_mencionados: [\"lista de campos que el doctor pidió dejar vacíos\"]\n  };\n}\n\nconst userPrompt = `TEXTO LIMPIO:\n${cleanedText}\n\nSECCIONES DETECTADAS:\n${detectedSections.join(', ')}\n\nPACIENTE:\n${JSON.stringify(inputData.patientData, null, 2)}\n\nESQUEMA ESPERADO:\n${JSON.stringify(fieldSchema, null, 2)}\n\nEXTRAE todos los datos clínicos siguiendo el esquema. Interpreta contexto.`;\n\nconst payload = {\n  model: 'llama-3.3-70b-versatile',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  temperature: 0.3,\n  response_format: { type: 'json_object' }\n};\n\nreturn {\n  ...inputData,\n  cleanedText: cleanedText,\n  detectedSections: detectedSections,\n  agent1Quality: cleanedData.quality_score || 0,\n  agentPayload: payload\n};"
			},
			"id": "agent2-prepare",
			"name": "AGENTE 2: Preparar Extracción",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1250, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "https://api.groq.com/openai/v1/chat/completions",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Authorization",
							"value": "=Bearer {{ $('1. Normalizar Entrada').item.json.groqApiKey }}"
						},
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={{ $json.agentPayload }}",
				"options": {}
			},
			"id": "agent2-execute",
			"name": "AGENTE 2: Ejecutar",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [1450, 400]
		},
		{
			"parameters": {
				"jsCode": "// Obtener respuesta del AGENTE 2\nconst agent2Response = $json.choices?.[0]?.message?.content;\n\n// Verificar que la respuesta existe\nif (!agent2Response) {\n  console.error('AGENTE 2: Respuesta vacía o inválida');\n  console.error('Estructura completa de $json:', JSON.stringify($json, null, 2));\n  throw new Error('AGENTE 2 falló: La respuesta de Groq está vacía o no tiene la estructura esperada');\n}\n\nlet extractedFields;\ntry {\n  if (typeof agent2Response !== 'string') {\n    console.error('AGENTE 2: agent2Response no es string:', typeof agent2Response, agent2Response);\n    throw new Error('La respuesta del AGENTE 2 no es un string válido');\n  }\n  extractedFields = JSON.parse(agent2Response);\n  \n  // Verificar que extractedFields no está vacío\n  if (!extractedFields || Object.keys(extractedFields).length === 0) {\n    console.warn('AGENTE 2: extractedFields está vacío');\n  }\n} catch (e) {\n  console.error('AGENTE 2: Error parseando JSON:', e.message);\n  console.error('AGENTE 2: Respuesta recibida:', agent2Response?.substring(0, 500));\n  throw new Error('AGENTE 2 falló: ' + e.message);\n}\n\nconst inputData = $('AGENTE 2: Preparar Extracción').item.json;\n\nconst systemPrompt = `Eres un agente VALIDADOR CLÍNICO con conocimiento médico profundo.\n\nTu función:\n1. Revisar datos extraídos por coherencia médica\n2. Detectar inconsistencias o contradicciones\n3. Inferir información implícita pero clara\n4. Normalizar terminología médica\n5. Identificar campos que requieren aclaración\n\nEjemplos de validación:\n- Si edad < 15 años y menciona parejas sexuales → FLAG de revisión\n- Si \"niega alergias\" → alergias: \"ninguna\" (no null)\n- Si \"mamas asimétricas\" → verificar que simetría sea false/no\n- Si última regla hace 60 días → calcular semanas de amenorrea\n\nResponde con JSON:\n{\n  \"validated_data\": { datos validados y enriquecidos },\n  \"inferences\": [\"lista de inferencias realizadas\"],\n  \"flags\": [\"advertencias o inconsistencias\"],\n  \"confidence\": 0-100\n}`;\n\nconst userPrompt = `DATOS EXTRAÍDOS:\n${JSON.stringify(extractedFields, null, 2)}\n\nTEXTO ORIGINAL COMPLETO:\n${inputData.cleanedText}\n\nPACIENTE: ${inputData.patientData.firstName} ${inputData.patientData.lastName}\nEDAD: ${inputData.patientData.age || 'no especificada'}\n\nVALIDA estos datos y enriquece con inferencias lógicas.`;\n\nconst payload = {\n  model: 'llama-3.3-70b-versatile',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  temperature: 0.2,\n  response_format: { type: 'json_object' }\n};\n\nreturn {\n  ...inputData,\n  extractedFields: extractedFields,\n  agentPayload: payload\n};"
			},
			"id": "agent3-prepare",
			"name": "AGENTE 3: Preparar Validación",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [1650, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "https://api.groq.com/openai/v1/chat/completions",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Authorization",
							"value": "=Bearer {{ $('1. Normalizar Entrada').item.json.groqApiKey }}"
						},
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={{ $json.agentPayload }}",
				"options": {}
			},
			"id": "agent3-execute",
			"name": "AGENTE 3: Ejecutar",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [1850, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "={{ $('1. Normalizar Entrada').item.json.nextAppUrl }}/api/n8n/analyze-template",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={\n  \"doctorId\": \"{{ $('1. Normalizar Entrada').item.json.doctorId }}\",\n  \"reportType\": \"{{ $('1. Normalizar Entrada').item.json.reportType }}\",\n  \"apiKey\": \"{{ $('1. Normalizar Entrada').item.json.n8nApiKey }}\"\n}",
				"options": {}
			},
			"id": "analyze-template",
			"name": "4. Analizar Plantilla Word",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [2050, 400]
		},
		{
			"parameters": {
				"jsCode": "// Obtener respuesta del AGENTE 3 desde el nodo correcto\n// NOTA: Este nodo recibe datos de '4. Analizar Plantilla Word', no de 'AGENTE 3: Ejecutar'\n// Por eso necesitamos obtener la respuesta del AGENTE 3 desde el nodo anterior\nlet agent3Response;\ntry {\n  const agent3Node = $('AGENTE 3: Ejecutar').item.json;\n  agent3Response = agent3Node.choices?.[0]?.message?.content;\n} catch (e) {\n  console.error('Error obteniendo respuesta del AGENTE 3:', e);\n  // Intentar obtener desde $json por si acaso\n  agent3Response = $json.choices?.[0]?.message?.content;\n}\n\n// Verificar que la respuesta existe\nif (!agent3Response) {\n  console.error('AGENTE 3: Respuesta vacía o inválida');\n  console.error('Estructura completa de $json:', JSON.stringify($json, null, 2));\n  throw new Error('AGENTE 3 falló: La respuesta de Groq está vacía o no tiene la estructura esperada');\n}\n\n// Obtener análisis de plantilla (este nodo recibe datos de '4. Analizar Plantilla Word')\nlet templateAnalysis;\ntry {\n  // $json ya contiene los datos de '4. Analizar Plantilla Word'\n  templateAnalysis = $json;\n  \n  // Verificar que tiene los campos esperados\n  if (!templateAnalysis.templateText && !templateAnalysis.variables) {\n    // Si no tiene los campos, intentar obtener desde el nodo explícitamente\n    templateAnalysis = $('4. Analizar Plantilla Word').item.json;\n  }\n} catch (e) {\n  console.error('Error obteniendo análisis de plantilla:', e);\n  throw new Error('No se pudo obtener el análisis de la plantilla: ' + e.message);\n}\n\n// Parsear respuesta del AGENTE 3\nlet validatedData;\ntry {\n  // Verificar que agent3Response es un string válido\n  if (typeof agent3Response !== 'string') {\n    console.error('AGENTE 3: agent3Response no es string:', typeof agent3Response, agent3Response);\n    throw new Error('La respuesta del AGENTE 3 no es un string válido');\n  }\n  \n  // Limpiar el string JSON (manejar saltos de línea y espacios extra)\n  let cleanedResponse = agent3Response.trim();\n  \n  // Si el string contiene \\n literales, reemplazarlos\n  cleanedResponse = cleanedResponse.replace(/\\\\n/g, ' ').replace(/\\\\t/g, ' ');\n  \n  // Intentar parsear el JSON\n  let validation;\n  try {\n    validation = JSON.parse(cleanedResponse);\n  } catch (parseError) {\n    // Si falla, intentar parsear el string original\n    console.warn('AGENTE 3: Primer intento de parseo falló, intentando con string original');\n    validation = JSON.parse(agent3Response);\n  }\n  \n  // Extraer validated_data (soportar tanto snake_case como camelCase)\n  validatedData = validation.validated_data || validation.validatedData || {};\n  \n  // Log para debugging\n  console.log('AGENTE 3: validated_data extraído, número de campos:', Object.keys(validatedData).length);\n  if (Object.keys(validatedData).length > 0) {\n    console.log('AGENTE 3: Primeros campos:', Object.keys(validatedData).slice(0, 5).join(', '));\n  }\n  \n  // Verificar que validatedData no está vacío\n  if (!validatedData || Object.keys(validatedData).length === 0) {\n    console.warn('AGENTE 3: validated_data está vacío, usando extractedFields como fallback');\n    const inputData = $('AGENTE 3: Preparar Validación').item.json;\n    validatedData = inputData.extractedFields || {};\n    console.warn('AGENTE 3: extractedFields tiene', Object.keys(validatedData).length, 'campos');\n  }\n} catch (e) {\n  console.error('AGENTE 3: Error parseando JSON:', e.message);\n  console.error('AGENTE 3: Respuesta recibida (primeros 1000 chars):', agent3Response?.substring(0, 1000));\n  \n  // Intentar usar extractedFields como fallback\n  try {\n    const inputData = $('AGENTE 3: Preparar Validación').item.json;\n    validatedData = inputData.extractedFields || {};\n    console.warn('AGENTE 3: Usando extractedFields como fallback debido a error de parseo');\n    console.warn('AGENTE 3: extractedFields tiene', Object.keys(validatedData).length, 'campos');\n    \n    // Si extractedFields también está vacío, lanzar error más descriptivo\n    if (!validatedData || Object.keys(validatedData).length === 0) {\n      throw new Error('AGENTE 3 falló: No se pudo obtener validated_data ni extractedFields. Error de parseo: ' + e.message);\n    }\n  } catch (fallbackError) {\n    throw new Error('AGENTE 3 falló: ' + e.message + '. Fallback también falló: ' + fallbackError.message);\n  }\n}\n\nconst inputData = $('AGENTE 3: Preparar Validación').item.json;\n\nconst templateText = templateAnalysis.templateText || '';\nconst templateVariables = templateAnalysis.variables || [];\n\n// NO GENERAR TEXTO - Solo preparar los datos para reemplazo de variables\n// El sistema usará docxtemplater para reemplazar directamente las variables {{}} en la plantilla\n// con los datos extraídos del audio\n\nconst systemPrompt = `Eres un agente EXTRACTOR DE PLAN DE TRATAMIENTO.\n\nTu ÚNICA función es:\n1. Identificar si en los datos validados hay información sobre PLAN DE TRATAMIENTO\n2. Extraer medicamentos mencionados con sus dosis y presentaciones\n3. Extraer recomendaciones específicas del doctor\n4. NO generar recomendaciones genéricas\n5. Si NO hay plan en los datos, retornar null\n\nResponde SOLO con JSON:\n{\n  \"plan\": \"texto del plan mencionado por el doctor\" o null,\n  \"medicamentos\": [\"medicamento 1 con dosis\", \"medicamento 2 con dosis\"] o [],\n  \"recomendaciones\": [\"recomendación 1\", \"recomendación 2\"] o []\n}`;\n\nconst userPrompt = `DATOS VALIDADOS DEL AUDIO:\n${JSON.stringify(validatedData, null, 2)}\n\nTEXTO ORIGINAL LIMPIO:\n${inputData.cleanedText || ''}\n\nEXTRAE el plan de tratamiento, medicamentos y recomendaciones SOLO si están mencionados en los datos. Si no hay plan, retorna null.`;\n\nconst payload = {\n  model: 'llama-3.3-70b-versatile',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  temperature: 0.2,\n  response_format: { type: 'json_object' },\n  max_tokens: 500\n};\n\nreturn {\n  ...inputData,\n  validatedData: validatedData,\n  templateAnalysis: templateAnalysis,\n  agentPayload: payload\n};"
			},
			"id": "agent4-prepare",
			"name": "AGENTE 4: Preparar Redacción",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [2250, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "https://api.groq.com/openai/v1/chat/completions",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Authorization",
							"value": "=Bearer {{ $('1. Normalizar Entrada').item.json.groqApiKey }}"
						},
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={{ $json.agentPayload }}",
				"options": {}
			},
			"id": "agent4-execute",
			"name": "AGENTE 4: Ejecutar",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [2450, 400]
		},
		{
			"parameters": {
				"jsCode": "// Extraer plan de tratamiento del AGENTE 4\nconst agent4Response = $json.choices?.[0]?.message?.content;\nlet planData = { plan: null, medicamentos: [], recomendaciones: [] };\n\ntry {\n  if (agent4Response) {\n    const parsed = JSON.parse(agent4Response);\n    planData = {\n      plan: parsed.plan || null,\n      medicamentos: parsed.medicamentos || [],\n      recomendaciones: parsed.recomendaciones || []\n    };\n  }\n} catch (e) {\n  console.warn('Error parseando plan de tratamiento:', e);\n}\n\nconst inputData = $('AGENTE 4: Preparar Redacción').item.json;\nconst validatedData = inputData.validatedData;\n\n// Agregar plan a los datos validados si existe\nif (planData.plan) {\n  validatedData.plan = planData.plan;\n  validatedData.plan_tratamiento = planData.plan;\n}\nif (planData.medicamentos && planData.medicamentos.length > 0) {\n  validatedData.medicamentos = planData.medicamentos;\n}\nif (planData.recomendaciones && planData.recomendaciones.length > 0) {\n  validatedData.recomendaciones = planData.recomendaciones;\n}\n\nlet updatedVitals = {};\nif (inputData.reportType === 'gynecology') {\n  updatedVitals.gynecology = validatedData;\n} else {\n  updatedVitals[inputData.reportType] = validatedData;\n}\n\n// NO enviar transcription generada - el sistema usará solo los datos para reemplazar variables\nconst payload = {\n  consultationId: inputData.consultationId,\n  doctorId: inputData.doctorId,\n  reportType: inputData.reportType,\n  transcription: '', // Vacío - no se usará texto generado\n  extractedFields: validatedData,\n  updatedVitals: updatedVitals,\n  apiKey: inputData.n8nApiKey\n};\n\nreturn {\n  ...inputData,\n  validatedData: validatedData,\n  planData: planData,\n  reportPayload: payload,\n  reportUrl: inputData.nextAppUrl + '/api/n8n/generate-report-internal'\n};"
			},
			"id": "prepare-word-generation",
			"name": "5. Preparar Generación Word",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [2650, 400]
		},
		{
			"parameters": {
				"method": "POST",
				"url": "={{ $json.reportUrl }}",
				"sendHeaders": true,
				"headerParameters": {
					"parameters": [
						{
							"name": "Content-Type",
							"value": "application/json"
						}
					]
				},
				"sendBody": true,
				"specifyBody": "json",
				"jsonBody": "={{ $json.reportPayload }}",
				"options": {}
			},
			"id": "generate-word",
			"name": "6. Generar Documento Word",
			"type": "n8n-nodes-base.httpRequest",
			"typeVersion": 4.2,
			"position": [2850, 400]
		},
		{
			"parameters": {
				"jsCode": "const wordResponse = $json;\nconst reportUrl = wordResponse.report_url || wordResponse.reportUrl || '';\n\nconst inputData = $('5. Preparar Generación Word').item.json;\n\nreturn {\n  success: true,\n  reportUrl: reportUrl,\n  transcription: inputData.cleanedText,\n  extractedFields: inputData.validatedData,\n  generatedReport: inputData.generatedReport,\n  processingTime: Date.now() - new Date(inputData.timestamp).getTime(),\n  agentMetrics: {\n    agent1_quality: inputData.agent1Quality,\n    confidence: 85\n  },\n  message: 'Informe generado exitosamente con sistema multi-agente'\n};"
			},
			"id": "prepare-response",
			"name": "7. Preparar Respuesta Final",
			"type": "n8n-nodes-base.code",
			"typeVersion": 2,
			"position": [3050, 400]
		},
		{
			"parameters": {
				"respondWith": "json",
				"responseBody": "={{ $json }}",
				"options": {}
			},
			"id": "respond-webhook",
			"name": "Respond to Webhook",
			"type": "n8n-nodes-base.respondToWebhook",
			"typeVersion": 1.1,
			"position": [3250, 400]
		}
	],
	"connections": {
		"Webhook Trigger": {
			"main": [[{ "node": "1. Normalizar Entrada", "type": "main", "index": 0 }]]
		},
		"1. Normalizar Entrada": {
			"main": [[{ "node": "2. Transcribir Audio (Groq Whisper)", "type": "main", "index": 0 }]]
		},
		"2. Transcribir Audio (Groq Whisper)": {
			"main": [[{ "node": "AGENTE 1: Preparar Limpieza", "type": "main", "index": 0 }]]
		},
		"AGENTE 1: Preparar Limpieza": {
			"main": [[{ "node": "AGENTE 1: Ejecutar", "type": "main", "index": 0 }]]
		},
		"AGENTE 1: Ejecutar": {
			"main": [[{ "node": "AGENTE 2: Preparar Extracción", "type": "main", "index": 0 }]]
		},
		"AGENTE 2: Preparar Extracción": {
			"main": [[{ "node": "AGENTE 2: Ejecutar", "type": "main", "index": 0 }]]
		},
		"AGENTE 2: Ejecutar": {
			"main": [[{ "node": "AGENTE 3: Preparar Validación", "type": "main", "index": 0 }]]
		},
		"AGENTE 3: Preparar Validación": {
			"main": [[{ "node": "AGENTE 3: Ejecutar", "type": "main", "index": 0 }]]
		},
		"AGENTE 3: Ejecutar": {
			"main": [[{ "node": "4. Analizar Plantilla Word", "type": "main", "index": 0 }]]
		},
		"4. Analizar Plantilla Word": {
			"main": [[{ "node": "AGENTE 4: Preparar Redacción", "type": "main", "index": 0 }]]
		},
		"AGENTE 4: Preparar Redacción": {
			"main": [[{ "node": "AGENTE 4: Ejecutar", "type": "main", "index": 0 }]]
		},
		"AGENTE 4: Ejecutar": {
			"main": [[{ "node": "5. Preparar Generación Word", "type": "main", "index": 0 }]]
		},
		"5. Preparar Generación Word": {
			"main": [[{ "node": "6. Generar Documento Word", "type": "main", "index": 0 }]]
		},
		"6. Generar Documento Word": {
			"main": [[{ "node": "7. Preparar Respuesta Final", "type": "main", "index": 0 }]]
		},
		"7. Preparar Respuesta Final": {
			"main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
		}
	},
	"settings": {
		"executionOrder": "v1"
	}
}
